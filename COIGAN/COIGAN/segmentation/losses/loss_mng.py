from cmath import nan
import torch
import numpy as np
import collections.abc

from . import dice_loss, bce_loss


class eval_losses_dict:
    """
    class to store the losses dicts.
    This object automatically store all the loss values from a passed dict generated by the loss manager,
    and automatically add the new values into lists for each key.
    """    

    def __init__(self, input_classes, classes, losses):
        
        self.n_samples = 0
        self.input_classes = input_classes
        self.classes = classes
        self.losses = losses

        # init the losses dict
        self.losses_dict = {
            "loss": [],
            "loss_nw": [],
            "input_class": []
        }
        for _class in self.classes:
            self.losses_dict[_class] = {
                "class_loss": [],
                "class_loss_w": []
            }
            for loss in self.losses:
                self.losses_dict[_class][loss] = []
                self.losses_dict[_class][f"{loss}_w"] = []


    def add_batch(self, losses_dicts):
        """
        Method that load the new losses dict and add the values to the losses_dict,
        but with the mean of the values instead of lists.
        """

        for losses_dict in losses_dicts:
            self.n_samples += 1
            for key, value in losses_dict.items():
                if isinstance(value, collections.abc.Mapping):
                    # if a value is a dict load it recursively
                    for _key, _value in value.items():
                        self.losses_dict[key][_key].append(_value.item())
                elif value is not None:
                    # if a value is not a dict add it to the losses dict
                    self.losses_dict[key].append(value.item() if torch.is_tensor(value) else value)


    def get_nw_losses_means_by_input_class(self):
        """
        Method that divide the losses_nw by the input class and compute the mean.
        and return it as a dict.

        Returns:
            {
                "input_class_1": 0.76,
                "input_class_2": 0.78,
                ...
            }
        """
        # create the dict container
        nw_losses_by_input_class = {
            input_class: []
            for input_class in self.input_classes
        }

        # divide the losses by the input class
        for input_class, loss in zip(self.losses_dict["input_class"], self.losses_dict["loss_nw"]):
            nw_losses_by_input_class[self.input_classes[input_class]].append(loss)

        # remove the keys with an empty list and compute the mean of the non empty lists
        for key in list(nw_losses_by_input_class.keys()):
            if not nw_losses_by_input_class[key]:
                del nw_losses_by_input_class[key]
            else:
                nw_losses_by_input_class[key] = np.mean(nw_losses_by_input_class[key])

        return nw_losses_by_input_class


    def get_classes_loss_means(self):
        """
        compute the mean class losses over the batch losses saved in the batch_losses list.
        """
        return {
            _class: np.mean(self.losses_dict[_class]["class_loss"])
            for _class in self.classes
        }


    def get_losses_loss_means(self):
        """
        compute the mean losses over the batch losses saved in the batch_losses list.
        """
        
        losses_loss = {
            loss: []
            for loss in self.losses
        }

        # aggregate all the losses by loss type
        for _class in self.classes:
            for loss in self.losses:
                losses_loss[loss].extend(self.losses_dict[_class][loss])
        
        # compute the mean of the losses
        for loss in self.losses:
            losses_loss[loss] = np.mean(losses_loss[loss])
        
        return losses_loss


    def get_loss_mean(self):
        """
        compute the mean loss over the batch losses saved in the batch_losses list.
        NOTE; this method return the mean of the loss weighted.
        """
        return np.mean(self.losses_dict["loss"])


class loss_mng:

    std_config = {
        "losses": {
            "dice": dice_loss(),
            "cross_entropy": bce_loss()
        },
        'classes': [
            'Bruise',
            'Dent',
            'Part missing',
            'Part displacement',
            'Crack',
            'Cracked glass',
            'Broken glass',
            'Broken headlight',
            'Damaged plate'
        ],
        "input_classes": [
            "damage",
            "no_damage"
        ],
        "loss_weights": [1.0, 1.0], # None means equal weights, applyed if the class_loss_weight is not defined for a class
        "classes_weights": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], # None means equal weights
        "input_classes_weights": [1.0, 1.0], # None means equal weights
    }

    def __init__(self, config=None, eval=False):
        """dict containing the as keys the names of the losses and as 
            Init method of the loss manager.

            Args:
                config (dict): dict specifing the loss manager configurations:
                    {
                        losses (dict(str, obj)): dict containing the as keys the names of the losses and as values the loss objects,
                        classes (List[str]): list of the classes names,
                        input_classes (List[str]): list of the input classes names,
                        loss_weights (List[float]): list of the loss weights as float, if None the weights are set to 1.0,
                        classes_weights (List[float]): list of the class weights as float, if None the weights are set to 1.0,
                        input_classes_weights (List[float]): list of the input class weights as float, if None the weights are set to 1.0,
                    }
                eval (bool, optional): if True the loss manager is in eval mode. Defaults to False.
                    In eval mode the loss manager accumulate the losses in a special dict that allow to compute the mean of the losses of the whole dataset.
        """
        if config is None:
            config = self.std_config
        
        self.losses = config["losses"]
        self.classes = config["classes"]
        self.input_classes = config["input_classes"]
        self.loss_weights = config["loss_weights"] if config["loss_weights"] is not None else [1.0] * len(self.losses)
        self.classes_weights = config["classes_weights"] if config["classes_weights"] is not None else [1.0] * len(self.classes)
        self.input_classes_weights = config["input_classes_weights"] if config["input_classes_weights"] is not None else [1.0] * len(self.input_classes)

        # check the configs and the weights lengths match the sizes
        if len(self.losses) != len(self.loss_weights):
            raise ValueError("The number of losses and the number of loss weights must be the same!")
        if len(self.classes) != len(self.classes_weights):
            raise ValueError("The number of classes and the number of classes weights must be the same!")
        if len(self.input_classes) != len(self.input_classes_weights) and self.input_classes_weights is not None:
            raise ValueError("The number of input classes and the number of input classes weights must be the same!")

        # list of dicts with the raw loss values for each sample in the batch
        self.batch_losses = []

        # final loss value
        self.loss = 0

        # eval flag
        self.eval = eval

        # init the dicts for the loss metrics that should saved over the entire evaluation dataset
        if self.eval:
            self.batches_losses_eval = eval_losses_dict(self.input_classes, self.classes, self.losses.keys())


    def __call__(self, pred_batch, target_batch, input_class_batch=None):
        """
            Method to compute the loss.
            The method compute each loss to each pred layer for each batch,
            and apply the weights to each singular loss based on the loss function,
            the class and the input class.

            Args:
                pred_batch (torch.tensor): batch of predictions.
                target_batch (torch.tensor): batch of targets.
                input_class_batch (list[int]): list of the input classes encoded as int, if None the input_classes weights are not applied.
            
            return:
                loss (torch.tensor): the loss value
            
            NOTE: the method generate the batch_losses dict with the following structure:
            sample_losses = {
                "loss": loss,               # the loss value weighted with the input class weight
                "loss_nw": loss_nw,         # the loss value without the input class weight
                "input_class": input_class, # the input class of the sample
                "class_name_1": {
                    "class_loss": class_loss,       # the loss value meaned over the sample's class's weighted losses
                    "class_loss_w": class_loss_w,   # the class loss weighted with the class weight
                    "loss_name_1": loss_value,              # the loss value for the loss_name_1
                    "loss_name_1_w": loss_value_weighted,   # the loss value weighted with the correspondent loss weight
                    "loss_name_2": loss_value,              # the loss value for the loss_name_2
                    "loss_name_2_w": loss_value_weighted,   # the loss value weighted with the correspondent loss weight
                    ...
                },
                "class_name_2": {
                    ...
                },
                ...
            }

        """

        #iter batches and comput singular losses
        self.batch_size = pred_batch.shape[0]

        # list of losses for each batch
        self.batch_losses = []
        for batch_idx in range(self.batch_size):
            sample_losses = {}
            pred = pred_batch[batch_idx]
            target = target_batch[batch_idx]

            # if the input class is passed save it in the correspondent sample
            if input_class_batch is not None:
                input_class = input_class_batch[batch_idx].item()
                sample_losses["input_class"] = input_class

            # compute the losses for each class
            for class_idx, class_name in enumerate(self.classes):
                # compute each loss for each class
                sample_losses[class_name] = {
                    loss_name: loss(pred[class_idx], target[class_idx])
                    for loss_name, loss in self.losses.items()
                }

            # aplly the weights to each loss and compute the resulting class loss and weighted class loss
            for class_idx, class_name in enumerate(self.classes):
                # compute the weighted value for each loss
                for loss_idx, (loss_name, _) in enumerate(self.losses.items()):
                    sample_losses[class_name][f"{loss_name}_w"] = self.loss_weights[loss_idx] * sample_losses[class_name][loss_name]


                # compute the weighted class loss
                sample_losses[class_name]["class_loss"] = sum(sample_losses[class_name][f"{loss_name}_w"] for loss_name in self.losses.keys())/len(self.losses)
                sample_losses[class_name]["class_loss_w"] = self.classes_weights[class_idx] * sample_losses[class_name]["class_loss"]


            # compute the sample loss
            sample_losses["loss_nw"] = sum(sample_losses[class_name]["class_loss_w"] for class_name in self.classes)/len(self.classes)

            if input_class_batch is not None:
                sample_losses["loss"] = self.input_classes_weights[input_class] * sample_losses["loss_nw"]
            else:
                sample_losses["loss"] = sample_losses["loss_nw"]

            # add the result losses in the batch losses
            self.batch_losses.append(sample_losses)


        # if the loss manager is in eval mode save the batch losses in the batches_losses dict
        if self.eval:
            self.batches_losses_eval.add_batch(self.batch_losses)

        else:
            # compute the mean loss over the batch
            self.loss = self.get_loss()

            return self.loss


    ### LOSS METHODS ###

    def get_losses_input_classwise(self):
        """
        create the input class wise losses dict.
        NOTE: if the batch dosen't have an input class, the corresponding input class is set to None

        return: a dict with the following structure:
            input_class_wise_losses = {
                "input_class_1": input_class_loss_1, # mean of the non weighted losses for the input class 1
                "input_class_2": input_class_loss_2, # mean of the non weighted losses for the input class 2
                ...
            }
        """

        #check if the batch has the input class
        if "input_class" not in self.batch_losses[0]:
            raise ValueError("The batch losses does not contain the input class, please pass the input class to the loss function")

        # init the input class wise losses dict
        input_class_losses = {
            input_class: []
            for input_class in self.input_classes
        }

        # accumulate the non weighted losses (loss_nw) for each input class in a separate list
        for sample_losses in self.batch_losses:
            input_class_losses[self.input_classes[sample_losses["input_class"]]].append(sample_losses["loss_nw"])
    
        # compute the mean of the non weighted losses for each input class and remove the empty input classes
        for input_class in self.input_classes:
            if input_class_losses[input_class]:
                input_class_losses[input_class] = sum(input_class_losses[input_class])/len(input_class_losses[input_class])
            else:
                del input_class_losses[input_class]
        
        return input_class_losses


    def get_losses_classwise(self):
        """
        create the class wise losses dict.

        return: a dict with the following structure:
            class_wise_losses = {
                "class_1": class_loss_1, # mean of the non weighted class losses for the input class 1
                "class_2": class_loss_2, # mean of the non weighted class losses for the input class 2
                ...
            }
        """

        class_losses = {
            _class: 0
            for _class in self.classes
        }

        # for each class compute the mean of the non weighted class losses
        for sample_losses in self.batch_losses:
            for _class in self.classes:
                class_losses[_class] += sample_losses[_class]["class_loss"].item()
        
        # divide the sum for the number of samples
        for _class in self.classes:
            class_losses[_class] /= len(self.batch_losses)
        
        return class_losses
    

    def get_losses_losswise(self):
        """
        create the loss wise losses dict.

        return: a dict with the following structure:
            loss_wise_losses = {
                "loss_1": loss_1, # mean of the non weighted losses for the loss 1
                "loss_2": loss_2, # mean of the non weighted losses for the loss 2
                ...
            }
        """

        loss_losses = {
            loss_name: 0
            for loss_name in self.losses.keys()
        }

        # for each loss compute the mean of the non weighted losses
        for sample_losses in self.batch_losses:
            for _class in self.classes:
                for loss_name in self.losses.keys():
                    loss_losses[loss_name] += sample_losses[_class][loss_name].item()
        
        # divide the sum for the number of samples dot the number of classes
        for loss_name in self.losses.keys():
            loss_losses[loss_name] /= len(self.batch_losses)*len(self.classes)
        
        return loss_losses
    
            
    def get_loss(self):
        """
        compute the mean loss over the batch losses saved in the batch_losses list.
        """
        return sum(sample_losses["loss"] for sample_losses in self.batch_losses)/len(self.batch_losses)


    ### VALIDATION LOSS METHODS ###

    def get_val_losses_input_classwise(self):
        """
        create the input class wise losses dict from the losses accumulated in the validation phase.

        return: a dict with the following structure:
            input_class_wise_losses = {
                "input_class_1": input_class_loss_1, # mean of the non weighted losses for the input class 1
                "input_class_2": input_class_loss_2, # mean of the non weighted losses for the input class 2
                ...
            }
        """
        return self.batches_losses_eval.get_nw_losses_means_by_input_class()


    def get_val_losses_classwise(self):
        """
        create the class wise losses dict from the losses accumulated in the validation phase.

        return: a dict with the following structure:
            class_wise_losses = {
                "class_1": class_loss_1, # mean of the non weighted class losses for the input class 1
                "class_2": class_loss_2, # mean of the non weighted class losses for the input class 2
                ...
            }
        """
        return self.batches_losses_eval.get_classes_loss_means()
    

    def get_val_losses_losswise(self):
        """
        create the loss wise losses dict from the losses accumulated in the validation phase.

        return: a dict with the following structure:
            loss_wise_losses = {
                "loss_1": loss_1, # mean of the non weighted losses for the loss 1
                "loss_2": loss_2, # mean of the non weighted losses for the loss 2
                ...
            }
        """
        return self.batches_losses_eval.get_losses_loss_means()
    

    def get_val_loss(self):
        """
        compute the mean loss over the validation losses accumulated in the validation phase.
        """
        return self.batches_losses_eval.get_loss_mean()
    

    def reset_val(self):
        """
        Reset the validation losses dict.
        Needed to reset the validation losses dict before a new validation phase.
        """
        self.batches_losses_eval = eval_losses_dict(self.input_classes, self.classes, self.losses.keys())